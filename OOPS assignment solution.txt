Constructor:
1. What is a constructor in Python? Explain its purpose and usage.

A constructor in Python is a special method used to initialize objects when they are created. It is typically used to set initial values for the object's attributes.


2.Differentiate between a parameterless constructor and a parameterized constructor in Python.

A parameterless constructor does not accept any arguments (except self), while a parameterized constructor accepts arguments to initialize the object with specific values.


3.How do you define a constructor in a Python class? Provide an example.

The constructor is defined using the __init__ method.
python
Copy
Edit
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age


4.Explain the __init__ method in Python and its role in constructors.

The __init__ method is called automatically when a new object is created. It initializes the object's attributes with values provided during object creation.


5.In a class named Person, create a constructor that initializes the name and age attributes. Provide an example of creating an object of this class.

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

person1 = Person("Alice", 25)


6.How can you call a constructor explicitly in Python? Give an example.

Python calls the constructor automatically during object creation. You can explicitly call it like this:
python
Copy
Edit
person1 = Person.__new__(Person)
person1.__init__("Alice", 25)


7.What is the significance of the self parameter in Python constructors? Explain with an example.

The self parameter represents the instance of the class. It is used to access the object's attributes and methods.
python
Copy
Edit
class Person:
    def __init__(self, name, age):
        self.name = name  # Accessing the object's attribute
        self.age = age


8.Discuss the concept of default constructors in Python. When are they used?

A default constructor is a constructor with no parameters or only default values. It is used when no specific initialization is required for the object.


9.Create a Python class called Rectangle with a constructor that initializes the width and height attributes. Provide a method to calculate the area of the rectangle.


class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height


10.How can you have multiple constructors in a Python class? Explain with an example.

Python does not support multiple constructors directly, but you can use class methods to achieve this.

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    @classmethod
    def from_birth_year(cls, name, birth_year):
        age = 2025 - birth_year
        return cls(name, age)


11.What is method overloading, and how is it related to constructors in Python?

Method overloading allows multiple methods with the same name but different parameters. In Python, overloading is not supported natively, but you can achieve similar behavior using default arguments.


12.Explain the use of the super() function in Python constructors. Provide an example.

The super() function is used to call a method from the parent class. It is commonly used to initialize attributes in a parent class from the child class.

class Animal:
    def __init__(self, name):
        self.name = name

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)
        self.breed = breed


13.Create a class called Book with a constructor that initializes the title, author, and published_year attributes. Provide a method to display book details.


class Book:
    def __init__(self, title, author, published_year):
        self.title = title
        self.author = author
        self.published_year = published_year

    def display(self):
        print(f"Title: {self.title}, Author: {self.author}, Year: {self.published_year}")


14.Discuss the differences between constructors and regular methods in Python classes.

Constructors (__init__) are special methods used to initialize objects when they are created. Regular methods are used to define the behavior of objects after they are created.


15.Explain the role of the self parameter in instance variable initialization within a constructor.

The self parameter is used to refer to the current instance of the class. Instance variables are initialized with self.variable_name = value inside the constructor.


16.How do you prevent a class from having multiple instances by using constructors in Python? Provide an example.

You can use the Singleton pattern to ensure only one instance of a class is created.

class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance


17.Create a Python class called Student with a constructor that takes a list of subjects as a parameter and initializes the subjects attribute.


class Student:
    def __init__(self, subjects):
        self.subjects = subjects


18.What is the purpose of the __del__ method in Python classes, and how does it relate to constructors?

The __del__ method is a destructor called when an object is about to be destroyed. It is used for clean-up tasks like releasing resources.


19.Explain the use of constructor chaining in Python. Provide a practical example.

Constructor chaining refers to calling another constructor within the current constructor. This can be done using super().

class A:
    def __init__(self, x):
        self.x = x

class B(A):
    def __init__(self, x, y):
        super().__init__(x)
        self.y = y


20.Create a Python class called Car with a default constructor that initializes the make and model attributes. Provide a method to display car information.

class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def display(self):
        print(f"Car Make: {self.make}, Model: {self.model}")
		


		
Inheritance

1.What is inheritance in Python? Explain its significance in object-oriented programming.

Inheritance allows a class to inherit attributes and methods from another class. It promotes code reusability and logical structure in object-oriented programming.


2.Differentiate between single inheritance and multiple inheritance in Python. Provide examples for each.

Single Inheritance: A class inherits from one parent class.
Multiple Inheritance: A class inherits from more than one parent class.

class Animal:
    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def speak(self):
        print("Dog barks")

class Cat(Animal):
    def speak(self):
        print("Cat meows")


3.Create a Python class called Vehicle with attributes color and speed. Then, create a child class called Car that inherits from Vehicle and adds a brand attribute. Provide an example of creating a Car object.


class Vehicle:
    def __init__(self, color, speed):
        self.color = color
        self.speed = speed

class Car(Vehicle):
    def __init__(self, color, speed, brand):
        super().__init__(color, speed)
        self.brand = brand

car = Car("Red", 100, "Toyota")
print(car.color, car.speed, car.brand)


4.Explain the concept of method overriding in inheritance. Provide a practical example.

Method overriding occurs when a child class provides a specific implementation of a method that is already defined in its parent class.

class Animal:
    def sound(self):
        print("Animal sound")

class Dog(Animal):
    def sound(self):
        print("Bark")

dog = Dog()
dog.sound()


5.How can you access the methods and attributes of a parent class from a child class in Python? Give an example.

Use super() to access parent methods and attributes.

class Parent:
    def greet(self):
        print("Hello from Parent")

class Child(Parent):
    def greet(self):
        super().greet()
        print("Hello from Child")

c = Child()
c.greet()


6.Discuss the use of the super() function in Python inheritance. When and why is it used? Provide an example.

super() is used to call a method from the parent class. It helps in method resolution order (MRO) and prevents repeating code in derived classes.

class Animal:
    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def speak(self):
        super().speak()
        print("Dog barks")

d = Dog()
d.speak()


7.Create a Python class called Animal with a method speak(). Then, create child classes Dog and Cat that inherit from Animal and override the speak() method. Provide an example of using these classes.


class Animal:
    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def speak(self):
        print("Dog barks")

class Cat(Animal):
    def speak(self):
        print("Cat meows")

d = Dog()
c = Cat()
d.speak()
c.speak()


8.Explain the role of the isinstance() function in Python and how it relates to inheritance.

isinstance() checks if an object is an instance of a specified class or a subclass.

class Animal:
    pass

class Dog(Animal):
    pass

d = Dog()
print(isinstance(d, Animal))  # True


9.What is the purpose of the issubclass() function in Python? Provide an example.

issubclass() checks if a class is a subclass of another class.

class Animal:
    pass

class Dog(Animal):
    pass

print(issubclass(Dog, Animal))  # True


10.Discuss the concept of constructor inheritance in Python. How are constructors inherited in child classes?

Child classes inherit the constructor of the parent class, but it can be overridden if needed. You can use super() to call the parent constructor.




11. Create a Python class called Shape with a method area() that calculates the area of a shape. Then, create child classes Circle and Rectangle that inherit from Shape and implement the area() method accordingly. Provide an example.

import math

class Shape:
    def area(self):
        raise NotImplementedError("Subclasses must implement this method")

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

# Example usage
circle = Circle(5)
rectangle = Rectangle(4, 6)

print("Circle Area:", circle.area())      # 78.54
print("Rectangle Area:", rectangle.area()) # 24



12. Explain the use of abstract base classes (ABCs) in Python and how they relate to inheritance. Provide an example using the abc module.

Abstract Base Classes (ABCs) enforce that child classes implement specific methods.

from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2

# shape = Shape()  # This will raise an error

circle = Circle(5)
print("Circle Area:", circle.area())  # 78.54



13. How can you prevent a child class from modifying certain attributes or methods inherited from a parent class in Python?

You can use private attributes (__) or final methods (@final from typing).

from typing import final

class Parent:
    def __init__(self):
        self.__secret = "Can't be modified"

    def get_secret(self):
        return self.__secret

    @final
    def final_method(self):
        print("Cannot be overridden")

class Child(Parent):
    pass

child = Child()
print(child.get_secret())  # Can't be modified



14. Create a Python class called Employee with attributes name and salary. Then, create a child class Manager that inherits from Employee and adds an attribute department. Provide an example.

class Employee:
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary

    def display(self):
        print(f"Name: {self.name}, Salary: {self.salary}")

class Manager(Employee):
    def __init__(self, name, salary, department):
        super().__init__(name, salary)
        self.department = department

    def display(self):
        print(f"Name: {self.name}, Salary: {self.salary}, Department: {self.department}")

mgr = Manager("Alice", 75000, "HR")
mgr.display()



15. Discuss the concept of method overloading in Python inheritance. How does it differ from method overriding?

Overloading: Python does not support traditional method overloading, but we can achieve similar behavior using default arguments.

Overriding: A child class provides a new implementation for an inherited method.

class Example:
    def show(self, a=None, b=None):
        if a is not None and b is not None:
            print(a, b)
        elif a is not None:
            print(a)
        else:
            print("No arguments")

obj = Example()
obj.show()       # No arguments
obj.show(5)      # 5
obj.show(5, 10)  # 5 10



16. Explain the purpose of the __init__() method in Python inheritance and how it is utilized in child classes.

The __init__() method initializes attributes and can be reused in child classes using super().

class Parent:
    def __init__(self, name):
        self.name = name

class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name)
        self.age = age

child = Child("John", 25)
print(child.name, child.age)  # John 25



17. Create a Python class called Bird with a method fly(). Then, create child classes Eagle and Sparrow that inherit from Bird and implement the fly() method differently.Provide an example of using these classes.

class Bird:
    def fly(self):
        raise NotImplementedError

class Eagle(Bird):
    def fly(self):
        print("Eagle flies high")

class Sparrow(Bird):
    def fly(self):
        print("Sparrow flies low")

eagle = Eagle()
sparrow = Sparrow()

eagle.fly()  # Eagle flies high
sparrow.fly()  # Sparrow flies low



18. What is the "diamond problem" in multiple inheritance, and how does Python address it?

The "diamond problem" occurs when multiple inheritance causes ambiguity. Python resolves this using Method Resolution Order (MRO).

class A:
    def show(self):
        print("A")

class B(A):
    def show(self):
        print("B")

class C(A):
    def show(self):
        print("C")

class D(B, C):  # Multiple Inheritance
    pass

obj = D()
obj.show()  # B (MRO follows left-to-right order)



19. Discuss the concept of "is-a" and "has-a" relationships in inheritance, and provide examples of each.

"Is-a" Relationship: Uses inheritance (Dog is an Animal).

"Has-a" Relationship: Uses composition (Car has an Engine).

class Engine:
    def start(self):
        print("Engine started")

class Car:
    def __init__(self):
        self.engine = Engine()  # Has-a relationship

    def start(self):
        self.engine.start()

car = Car()
car.start()  # Engine started



20. Create a Python class hierarchy for a university system.

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Student(Person):
    def __init__(self, name, age, student_id):
        super().__init__(name, age)
        self.student_id = student_id

class Professor(Person):
    def __init__(self, name, age, subject):
        super().__init__(name, age)
        self.subject = subject

s = Student("Alice", 20, "S123")
p = Professor("Dr. Smith", 45, "Physics")
s.display()
p.display()




Encapsulation

1. Explain the concept of encapsulation in Python. What is its role in object-oriented programming?

Encapsulation is a fundamental principle of OOP that restricts direct access to an object's data and only allows it to be accessed through well-defined methods. It enhances data security and integrity by preventing unintended modifications.


2. Describe the key principles of encapsulation, including access control and data hiding.

Encapsulation involves:

Access Control: Using access modifiers (public, protected, private) to restrict access to class attributes and methods.

Data Hiding: Preventing direct access to sensitive data to ensure controlled manipulation through methods.


3. How can you achieve encapsulation in Python classes? Provide an example.

class Car:
    def __init__(self, brand, speed):
        self.__brand = brand  # Private attribute
        self.__speed = speed  # Private attribute
    
    def get_speed(self):
        return self.__speed
    
    def set_speed(self, speed):
        if speed > 0:
            self.__speed = speed

car = Car("Toyota", 120)
print(car.get_speed())  # Accessing private attribute through method


4. Discuss the difference between public, private, and protected access modifiers in Python.


Public (attribute): Accessible from anywhere.

Protected (_attribute): Intended to be used within the class and its subclasses.

Private (__attribute): Cannot be accessed directly; uses name mangling.



5. Create a Python class called Person with a private attribute __name. Provide methods to get and set the name attribute.


class Person:
    def __init__(self, name):
        self.__name = name
    
    def get_name(self):
        return self.__name
    
    def set_name(self, name):
        self.__name = name



6. Explain the purpose of getter and setter methods in encapsulation. Provide examples.


Getters and setters help control access to private attributes and ensure data validation before modification.

class Employee:
    def __init__(self, salary):
        self.__salary = salary
    
    def get_salary(self):
        return self.__salary
    
    def set_salary(self, salary):
        if salary > 0:
            self.__salary = salary



7. What is name mangling in Python, and how does it affect encapsulation?


Name mangling is a mechanism where Python modifies private attributes using classname__attribute to prevent direct access.

class Test:
    def __init__(self):
        self.__hidden = 42

obj = Test()
print(obj._Test__hidden)  # Accessing private attribute




8. Create a Python class called BankAccount with private attributes for balance and account number. Provide methods for deposit and withdrawal.


class BankAccount:
    def __init__(self, account_number, balance):
        self.__account_number = account_number
        self.__balance = balance
    
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
    
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount



9. Discuss the advantages of encapsulation in terms of code maintainability and security.


Encapsulation improves:

Security: Prevents unintended modification of data.

Code Maintainability: Centralized control over data.

Data Integrity: Ensures controlled access.




10. How can you access private attributes in Python? Provide an example demonstrating name mangling.


class Sample:
    def __init__(self):
        self.__data = "Secret"

obj = Sample()
print(obj._Sample__data)  # Accessing private attribute




11. Create a Python class hierarchy for a school system, implementing encapsulation principles.


class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age
    
    def get_name(self):
        return self.__name

class Student(Person):
    def __init__(self, name, age, student_id):
        super().__init__(name, age)
        self.__student_id = student_id




12. Explain property decorators in Python and how they relate to encapsulation.


Property decorators (@property) allow controlled access to private attributes without explicit getter and setter methods.

class Example:
    def __init__(self, value):
        self.__value = value

    @property
    def value(self):
        return self.__value




13. What is data hiding, and why is it important in encapsulation? Provide examples.


Data hiding restricts access to critical information to prevent unintended modifications.

class Account:
    def __init__(self, balance):
        self.__balance = balance




14. Create an Employee class with private attributes for salary and employee ID. Provide a method to calculate bonuses.


class Employee:
    def __init__(self, salary, emp_id):
        self.__salary = salary
        self.__emp_id = emp_id
    
    def calculate_bonus(self):
        return self.__salary * 0.1




15. Discuss accessors and mutators in encapsulation.

Accessors (getters) retrieve data, while mutators (setters) modify data in a controlled manner.




16. What are the drawbacks of using encapsulation in Python?

Slight performance overhead.

Extra code complexity.




17. Create a Python class for a library system with encapsulation.


class Library:
    def __init__(self, books):
        self.__books = books
    
    def get_books(self):
        return self.__books




18. Explain how encapsulation enhances code reusability and modularity.


Encapsulation enables reusable components by preventing unintended modifications.




19. Describe information hiding in encapsulation and its importance.

Information hiding prevents external access to sensitive data, ensuring controlled access.




20. Create a Python class Customer with private attributes for name, address, and contact information.


class Customer:
    def __init__(self, name, address, contact):
        self.__name = name
        self.__address = address
        self.__contact = contact
    
    def get_contact(self):
        return self.__contact

This document provides a comprehensive understanding of encapsulation in Python.




Polymorphism


1. What is polymorphism in Python? Explain how it is related to object-oriented programming.

Polymorphism in Python refers to the ability of different classes to be treated as instances of the same class through a common interface. It allows methods to behave differently based on the object that calls them. Polymorphism is a core concept in object-oriented programming (OOP) that promotes flexibility and reusability by enabling a single interface to represent different underlying forms (data types).

In OOP, polymorphism is often achieved through inheritance and method overriding, where a subclass can provide a specific implementation of a method that is already defined in its superclass.


2. Describe the difference between compile-time polymorphism and runtime polymorphism in Python.
Compile-time polymorphism: This is achieved through method overloading, where multiple methods with the same name but different parameters are defined. Python does not support compile-time polymorphism directly because it does not support method overloading in the traditional sense.

Runtime polymorphism: This is achieved through method overriding, where a subclass provides a specific implementation of a method that is already defined in its superclass. Python supports runtime polymorphism, allowing the method to be resolved at runtime based on the object's type.


3. Create a Python class hierarchy for shapes and demonstrate polymorphism through a common method, such as calculate_area().

class Shape:
    def calculate_area(self):
        raise NotImplementedError("Subclasses must implement this method")

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def calculate_area(self):
        return 3.14 * self.radius ** 2

class Square(Shape):
    def __init__(self, side):
        self.side = side

    def calculate_area(self):
        return self.side ** 2

class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def calculate_area(self):
        return 0.5 * self.base * self.height

# Polymorphism in action
shapes = [Circle(5), Square(4), Triangle(3, 6)]
for shape in shapes:
    print(f"Area of {shape.__class__.__name__}: {shape.calculate_area()}")



4. Explain the concept of method overriding in polymorphism. Provide an example.

Method overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass. This allows the subclass to modify or extend the behavior of the method.

Example:


class Animal:
    def speak(self):
        return "Animal sound"

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

# Method overriding in action
animals = [Dog(), Cat()]
for animal in animals:
    print(animal.speak())
	
	
	
5. How is polymorphism different from method overloading in Python? Provide examples for both.

Polymorphism: Achieved through method overriding, where a subclass provides a specific implementation of a method.

Method overloading: Involves defining multiple methods with the same name but different parameters. Python does not support method overloading directly.

Example of Polymorphism:


class Animal:
    def speak(self):
        return "Animal sound"

class Dog(Animal):
    def speak(self):
        return "Woof!"
Example of Method Overloading (Not supported directly in Python):
Python uses default arguments or variable-length arguments to simulate overloading:


class Math:
    def add(self, a, b, c=None):
        if c is not None:
            return a + b + c
        return a + b

math = Math()
print(math.add(2, 3))       # Output: 5
print(math.add(2, 3, 4))    # Output: 9



6. Create a Python class called Animal with a method speak(). Then, create child classes like Dog, Cat, and Bird, each with their own speak() method. Demonstrate polymorphism by calling the speak() method on objects of different subclasses.
python
Copy
class Animal:
    def speak(self):
        raise NotImplementedError("Subclasses must implement this method")

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

class Bird(Animal):
    def speak(self):
        return "Chirp!"

# Polymorphism in action
animals = [Dog(), Cat(), Bird()]
for animal in animals:
    print(animal.speak())
	
	
	
7. Discuss the use of abstract methods and classes in achieving polymorphism in Python. Provide an example using the abc module.

Abstract methods and abstract classes are used to define a common interface for subclasses. The abc module in Python provides tools for creating abstract base classes.

Example:


from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def calculate_area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def calculate_area(self):
        return 3.14 * self.radius ** 2

# Polymorphism in action
shape = Circle(5)
print(shape.calculate_area())


8. Create a Python class hierarchy for a vehicle system and implement a polymorphic start() method that prints a message specific to each vehicle type.

class Vehicle:
    def start(self):
        raise NotImplementedError("Subclasses must implement this method")

class Car(Vehicle):
    def start(self):
        return "Car started with a key"

class Bicycle(Vehicle):
    def start(self):
        return "Bicycle started by pedaling"

class Boat(Vehicle):
    def start(self):
        return "Boat started with an engine"


vehicles = [Car(), Bicycle(), Boat()]
for vehicle in vehicles:
    print(vehicle.start())
	
	
	
9. Explain the significance of the isinstance() and issubclass() functions in Python polymorphism.
isinstance(): Checks if an object is an instance of a specific class or a subclass.

issubclass(): Checks if a class is a subclass of another class.

These functions are useful for ensuring that objects adhere to a specific interface or hierarchy, enabling polymorphic behavior.

Example:


class Animal: pass
class Dog(Animal): pass

dog = Dog()
print(isinstance(dog, Animal))  # Output: True
print(issubclass(Dog, Animal))  # Output: True



10. What is the role of the @abstractmethod decorator in achieving polymorphism in Python? Provide an example.

The @abstractmethod decorator is used to declare a method as abstract, meaning it must be implemented by subclasses. This enforces a common interface, enabling polymorphism.

Example:


from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

# Polymorphism in action
dog = Dog()
print(dog.speak())


11. Create a Python class called Shape with a polymorphic method area() that calculates the area of different shape.

class Shape:
    def area(self):
        raise NotImplementedError("Subclasses must implement this method")

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height


shapes = [Circle(5), Rectangle(4, 6)]
for shape in shapes:
    print(f"Area of {shape.__class__.__name__}: {shape.area()}")
	
	
	
12. Discuss the benefits of polymorphism in terms of code reusability and flexibility in Python programs.

Code reusability: Polymorphism allows you to write generic code that works with objects of different classes, reducing redundancy.

Flexibility: It enables you to extend functionality by adding new subclasses without modifying existing code.

Maintainability: Polymorphic code is easier to maintain and debug because it adheres to a common interface.




13. Explain the use of the super() function in Python polymorphism. How does it help call methods of parent classes?
The super() function is used to call a method from the parent class. It is useful in method overriding to extend the functionality of the parent method.

Example:


class Animal:
    def speak(self):
        return "Animal sound"

class Dog(Animal):
    def speak(self):
        return super().speak() + " but specifically Woof!"

dog = Dog()
print(dog.speak())  # Output: "Animal sound but specifically Woof!"



14. Create a Python class hierarchy for a banking system and demonstrate polymorphism by implementing a common withdraw() method.

class Account:
    def withdraw(self, amount):
        raise NotImplementedError("Subclasses must implement this method")

class SavingsAccount(Account):
    def withdraw(self, amount):
        return f"Withdrawing {amount} from Savings Account"

class CheckingAccount(Account):
    def withdraw(self, amount):
        return f"Withdrawing {amount} from Checking Account"

# Polymorphism in action
accounts = [SavingsAccount(), CheckingAccount()]
for account in accounts:
    print(account.withdraw(100))
	
	
15. Describe the concept of operator overloading in Python and how it relates to polymorphism. Provide examples using operators like + and *.

Operator overloading allows you to define custom behavior for operators like + and * for user-defined classes. It is a form of polymorphism because the same operator can behave differently based on the operands.

Example:

python
Copy
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)

v1 = Vector(2, 3)
v2 = Vector(4, 5)
v3 = v1 + v2  # Uses __add__
v4 = v1 * 2   # Uses __mul__
print(v3.x, v3.y)  # Output: 6, 8
print(v4.x, v4.y)  # Output: 4, 6



16. What is dynamic polymorphism, and how is it achieved in Python?
Dynamic polymorphism refers to the ability of a method to behave differently based on the object's type at runtime. It is achieved through method overriding in Python.

Example:


class Animal:
    def speak(self):
        return "Animal sound"

class Dog(Animal):
    def speak(self):
        return "Woof!"

# Dynamic polymorphism in action
animal = Dog()
print(animal.speak())  # Output: "Woof!"



17. Create a Python class hierarchy for employees in a company and implement polymorphism through a common calculate_salary() method.

class Employee:
    def calculate_salary(self):
        raise NotImplementedError("Subclasses must implement this method")

class Manager(Employee):
    def calculate_salary(self):
        return 100000

class Developer(Employee):
    def calculate_salary(self):
        return 80000

class Designer(Employee):
    def calculate_salary(self):
        return 70000

# Polymorphism in action
employees = [Manager(), Developer(), Designer()]
for employee in employees:
    print(f"Salary of {employee.__class__.__name__}: {employee.calculate_salary()}")
	
	
	
18. Discuss the concept of function pointers and how they can be used to achieve polymorphism in Python.
In Python, functions are first-class objects, meaning they can be passed as arguments, returned from functions, and assigned to variables. This allows you to achieve polymorphism by passing different functions to the same interface.

Example:

def dog_speak():
    return "Woof!"

def cat_speak():
    return "Meow!"

def animal_sound(speak_function):
    return speak_function()

# Polymorphism in action
print(animal_sound(dog_speak))  # Output: "Woof!"
print(animal_sound(cat_speak))  # Output: "Meow!"



19. Explain the role of interfaces and abstract classes in polymorphism, drawing comparisons between them.
Interfaces: Define a contract for methods that must be implemented by subclasses. Python does not have a built-in concept of interfaces, but abstract classes can serve a similar purpose.

Abstract classes: Provide a base class with abstract methods that must be implemented by subclasses. They can also include concrete methods.

Comparison:

Both enforce a common interface.

Abstract classes can include implementation details, while interfaces cannot.



20. Create a Python class for a zoo simulation, demonstrating polymorphism with different animal types.

class Animal:
    def make_sound(self):
        raise NotImplementedError("Subclasses must implement this method")

class Mammal(Animal):
    def make_sound(self):
        return "Roar!"

class Bird(Animal):
    def make_sound(self):
        return "Chirp!"

class Reptile(Animal):
    def make_sound(self):
        return "Hiss!"

# Polymorphism in action
animals = [Mammal(), Bird(), Reptile()]
for animal in animals:
    print(animal.make_sound())



Abstraction
1. What is abstraction in Python, and how does it relate to object-oriented programming?

Abstraction in Python refers to the concept of hiding the complex implementation details of a system and exposing only the necessary features. It simplifies interaction with objects by allowing the user to focus on high-level operations without worrying about low-level complexities. In object-oriented programming (OOP), abstraction helps in defining abstract classes and methods that are common to a set of related classes, ensuring that certain behavior is implemented by derived classes.


2. Describe the benefits of abstraction in terms of code organization and complexity reduction.


Code Organization: Abstraction helps in structuring code in a way that reduces duplication and keeps it organized by allowing common functionality to be defined in base classes.
Complexity Reduction: By hiding unnecessary implementation details, abstraction reduces the complexity faced by developers. It provides a simple interface for interacting with objects.



3. Create a Python class called Shape with an abstract method calculate_area(). Then, create child classes (e.g., Circle, Rectangle) that implement the calculate_area() method. Provide an example of using these classes.

from abc import ABC, abstractmethod
import math

class Shape(ABC):
    @abstractmethod
    def calculate_area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def calculate_area(self):
        return math.pi * self.radius ** 2

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def calculate_area(self):
        return self.width * self.height

# Example Usage
circle = Circle(5)
rectangle = Rectangle(4, 6)

print(f"Circle area: {circle.calculate_area()}")
print(f"Rectangle area: {rectangle.calculate_area()}")



4. Explain the concept of abstract classes in Python and how they are defined using the abc module. Provide an example.
An abstract class in Python is a class that cannot be instantiated directly. It is meant to serve as a blueprint for other classes. You define abstract classes using the ABC class from the abc module and mark methods as abstract with the @abstractmethod decorator.
Example:


from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Bark"

# animal = Animal()  # This will raise an error
dog = Dog()
print(dog.sound())  # Outputs: Bark


5. How do abstract classes differ from regular classes in Python? Discuss their use cases.
Abstract Classes: Cannot be instantiated directly and are used to define common interfaces or behaviors for subclasses. They require subclasses to implement abstract methods.
Regular Classes: Can be instantiated and may contain both fully implemented methods and abstract methods.
Use Case: Abstract classes are used when you want to ensure that certain methods are implemented by subclasses, which is common in frameworks or libraries where base functionality is defined but behavior varies.



6. Create a Python class for a bank account and demonstrate abstraction by hiding the account balance and providing methods to deposit and withdraw funds.

class BankAccount:
    def __init__(self, account_number):
        self.account_number = account_number
        self.__balance = 0  # Encapsulation: Account balance is private

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount

    def withdraw(self, amount):
        if amount > 0 and self.__balance >= amount:
            self.__balance -= amount

    def get_balance(self):
        return self.__balance

# Example Usage
account = BankAccount("12345")
account.deposit(500)
account.withdraw(200)
print(account.get_balance())  # Outputs: 300


7. Discuss the concept of interface classes in Python and their role in achieving abstraction.

Interface Classes: In Python, interfaces aren't formally defined as in languages like Java, but they can be simulated using abstract base classes with abstract methods. An interface defines a contract that classes must follow, ensuring that specific methods are implemented.
Role in Abstraction: Interfaces provide a way to enforce that certain methods are implemented by the classes, achieving abstraction by defining the "what" but leaving the "how" to the concrete classes.


8. Create a Python class hierarchy for animals and implement abstraction by defining common methods (e.g., eat(), sleep()) in an abstract base class.

from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def eat(self):
        pass

    @abstractmethod
    def sleep(self):
        pass

class Dog(Animal):
    def eat(self):
        return "Dog is eating."

    def sleep(self):
        return "Dog is sleeping."

class Cat(Animal):
    def eat(self):
        return "Cat is eating."

    def sleep(self):
        return "Cat is sleeping."

# Example Usage
dog = Dog()
cat = Cat()

print(dog.eat())  # Outputs: Dog is eating.
print(cat.sleep())  # Outputs: Cat is sleeping.


9. Explain the significance of encapsulation in achieving abstraction. Provide examples.
Encapsulation refers to bundling the data (attributes) and methods that operate on the data into a single unit (class) and restricting direct access to some of the object's components. It helps achieve abstraction by hiding the internal state and requiring all interaction to be done through well-defined methods.
Example:

In the bank account class, the account balance is private (__balance) and is only accessible via deposit, withdraw, and get_balance methods, preventing external modifications directly.



10. What is the purpose of abstract methods, and how do they enforce abstraction in Python classes?
Abstract Methods define a method signature that must be implemented in a derived class. They enforce abstraction by specifying that the subclass should provide a specific implementation, ensuring that certain functionality is always present, but hiding the details of the implementation.


11. Create a Python class for a vehicle system and demonstrate abstraction by defining common methods (e.g., start(), stop()) in an abstract base class.

from abc import ABC, abstractmethod

class Vehicle(ABC):
    @abstractmethod
    def start(self):
        pass

    @abstractmethod
    def stop(self):
        pass

class Car(Vehicle):
    def start(self):
        return "Car is starting."

    def stop(self):
        return "Car is stopping."

class Bike(Vehicle):
    def start(self):
        return "Bike is starting."

    def stop(self):
        return "Bike is stopping."

# Example Usage
car = Car()
bike = Bike()

print(car.start())  # Outputs: Car is starting.
print(bike.stop())  # Outputs: Bike is stopping.



12. Describe the use of abstract properties in Python and how they can be employed in abstract classes.
Abstract Properties are properties defined in an abstract class using the @property decorator and @abstractmethod. They enforce the requirement that subclasses provide the implementation for getting and setting the property.
Example:


from abc import ABC, abstractmethod

class Shape(ABC):
    @property
    @abstractmethod
    def area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    @property
    def area(self):
        return math.pi * self.radius ** 2

circle = Circle(5)
print(circle.area)  # Outputs: 78.53981633974483



13. Create a Python class hierarchy for employees in a company (e.g., manager, developer, designer) and implement abstraction by defining a common get_salary() method.

from abc import ABC, abstractmethod

class Employee(ABC):
    @abstractmethod
    def get_salary(self):
        pass

class Manager(Employee):
    def get_salary(self):
        return 60000

class Developer(Employee):
    def get_salary(self):
        return 50000

class Designer(Employee):
    def get_salary(self):
        return 40000

# Example Usage
manager = Manager()
developer = Developer()
designer = Designer()

print(manager.get_salary())  # Outputs: 60000
print(developer.get_salary())  # Outputs: 50000



14. Discuss the differences between abstract classes and concrete classes in Python, including their instantiation.

Abstract Classes cannot be instantiated directly. They are designed to be subclassed, with abstract methods that must be implemented in the subclass.
Concrete Classes are fully implemented classes that can be instantiated directly.


15. Explain the concept of abstract data types (ADTs) and their role in achieving abstraction in Python.
Abstract Data Types (ADTs) are a conceptual model for data types that define the behavior of data, but not the implementation. ADTs provide an abstraction by specifying the operations that can be performed on the data and the rules governing them, without exposing how the data is stored or manipulated internally.



16. Create a Python class for a computer system, demonstrating abstraction by defining common methods (e.g., power_on(), shutdown()) in an abstract base class.

from abc import ABC, abstractmethod

class ComputerSystem(ABC):
    @abstractmethod
    def power_on(self):
        pass

    @abstractmethod
    def shutdown(self):
        pass

class Desktop(ComputerSystem):
    def power_on(self):
        return "Desktop is powered on."

    def shutdown(self):
        return "Desktop is shutting down."

class Laptop(ComputerSystem):
    def power_on(self):
        return "Laptop is powered on."

    def shutdown(self):
        return "Laptop is shutting down."

# Example Usage
desktop = Desktop()
laptop = Laptop()

print(desktop.power_on())  # Outputs: Desktop is powered on.
print(laptop.shutdown())  # Outputs: Laptop is shutting down.



17. Discuss the benefits of using abstraction in large-scale software development projects.

Separation of Concerns: Different components can be developed independently, as abstraction hides the implementation details.
Code Reusability: Abstracted classes provide reusable code that can be easily extended by other parts of the system.
Flexibility: Changes in the implementation of an abstracted method don’t affect code using the abstraction, as long as the interface remains the same.


18. Explain how abstraction enhances code reusability and modularity in Python programs.
Reusability: By abstracting common functionality, classes can be reused without needing to rewrite code for each new use case.
Modularity: Abstraction promotes modularity by separating concerns, allowing different modules of a system to interact without knowing the specifics of each other's implementation.


19. Create a Python class for a library system, implementing abstraction by defining common methods (e.g., add_book(), borrow_book()) in an abstract base class.

from abc import ABC, abstractmethod

class LibrarySystem(ABC):
    @abstractmethod
    def add_book(self, book_name):
        pass

    @abstractmethod
    def borrow_book(self, book_name):
        pass

class Library(LibrarySystem):
    def add_book(self, book_name):
        print(f"Added {book_name} to the library.")

    def borrow_book(self, book_name):
        print(f"Borrowed {book_name} from the library.")

# Example Usage
library = Library()
library.add_book("Python Programming")
library.borrow_book("Python Programming")



20. Describe the concept of method abstraction in Python and how it relates to polymorphism.

Method Abstraction hides the specific implementation of a method in a base class while requiring derived classes to provide their own implementations. This allows polymorphism, where the same method can behave differently based on the object's type.




1.Explain the concept of composition in Python and how it is used to build complex objects from simpler ones.

Composition in Python is a design principle where one class contains instances of other classes as attributes. This allows building complex objects from simpler, reusable components. It is a "has-a" relationship, where a class represents a more complex object by using simpler objects.

Example:

class Engine:
    def start(self):
        print("Engine started")

class Car:
    def __init__(self, engine: Engine):
        self.engine = engine

    def drive(self):
        self.engine.start()
        print("Car is driving")


2. Describe the difference between composition and inheritance in object-oriented programming.
Composition: A "has-a" relationship where one class contains an instance of another class to build complex functionality. It's more flexible and allows changes to composed objects without affecting other classes.
Inheritance: An "is-a" relationship where one class inherits attributes and methods from another. It’s more rigid, which can lead to issues with tight coupling and inheritance hierarchies.



3. Create a Python class called Author with attributes for name and birthdate. Then, create a Book class that contains an instance of Author as a composition. Provide an example of creating a Book object.

class Author:
    def __init__(self, name, birthdate):
        self.name = name
        self.birthdate = birthdate

class Book:
    def __init__(self, title, author: Author):
        self.title = title
        self.author = author

# Example
author = Author("J.K. Rowling", "1965-07-31")
book = Book("Harry Potter", author)



4. Discuss the benefits of using composition over inheritance in Python, especially in terms of code flexibility and reusability.
Flexibility: Objects can be easily modified at runtime, and new behaviors can be added by swapping components.
Reusability: Components can be reused across different classes without creating rigid inheritance structures.
Maintainability: Composition keeps the code modular, making it easier to maintain.



5. How can you implement composition in Python classes? Provide examples of using composition to create complex objects.

Composition is implemented by creating an object of one class inside another class and using it to build the behavior of the second class.

Example:


class Engine:
    def start(self):
        print("Engine started")

class Car:
    def __init__(self):
        self.engine = Engine()

    def drive(self):
        self.engine.start()
        print("Car is driving")
		
6. Create a Python class hierarchy for a music player system, using composition to represent playlists and songs.

class Song:
    def __init__(self, title, artist):
        self.title = title
        self.artist = artist

class Playlist:
    def __init__(self):
        self.songs = []

    def add_song(self, song: Song):
        self.songs.append(song)

class MusicPlayer:
    def __init__(self):
        self.playlist = Playlist()

    def play(self):
        for song in self.playlist.songs:
            print(f"Playing {song.title} by {song.artist}")
			
			
7. Explain the concept of "has-a" relationships in composition and how it helps design software systems.
The "has-a" relationship is a key feature of composition, meaning that an object "has" one or more other objects as its components, allowing flexibility and modular design. This contrasts with inheritance's "is-a" relationship, which implies a stronger dependency between classes.


8. Create a Python class for a computer system, using composition to represent components like CPU, RAM, and storage devices.

class CPU:
    def process(self):
        print("Processing data...")

class RAM:
    def store(self):
        print("Storing data...")

class Storage:
    def save(self):
        print("Saving data...")

class Computer:
    def __init__(self):
        self.cpu = CPU()
        self.ram = RAM()
        self.storage = Storage()

    def operate(self):
        self.cpu.process()
        self.ram.store()
        self.storage.save()
		
		
9. Describe the concept of "delegation" in composition and how it simplifies the design of complex systems.
Delegation involves passing responsibilities from one object to another. This simplifies the design by allowing an object to delegate specific tasks to its composed objects, rather than implementing them itself.

Example:

class Printer:
    def print_document(self, document):
        print(f"Printing {document}")

class Computer:
    def __init__(self):
        self.printer = Printer()
    
    def print(self, document):
        self.printer.print_document(document)
		
		
10. Create a Python class for a car, using composition to represent components like the engine, wheels, and transmission.

class Engine:
    def start(self):
        print("Engine started")

class Wheel:
    def rotate(self):
        print("Wheels rotating")

class Car:
    def __init__(self):
        self.engine = Engine()
        self.wheels = [Wheel() for _ in range(4)]

    def drive(self):
        self.engine.start()
        for wheel in self.wheels:
            wheel.rotate()
			
			
			
11. How can you encapsulate and hide the details of composed objects in Python classes to maintain abstraction?
To encapsulate and hide the details of composed objects, you can provide public methods that interact with the composed objects, but the inner workings are hidden from the user.

Example:


class Engine:
    def start(self):
        print("Engine started")

class Car:
    def __init__(self):
        self.__engine = Engine()

    def drive(self):
        self.__engine.start()
        print("Car is driving")
		
		
		
12. Create a Python class for a university course, using composition to represent students, instructors, and course materials.

class Student:
    def __init__(self, name):
        self.name = name

class Instructor:
    def __init__(self, name):
        self.name = name

class CourseMaterial:
    def __init__(self, material):
        self.material = material

class Course:
    def __init__(self, title):
        self.title = title
        self.students = []
        self.instructors = []
        self.materials = []

    def add_student(self, student: Student):
        self.students.append(student)

    def add_instructor(self, instructor: Instructor):
        self.instructors.append(instructor)

    def add_material(self, material: CourseMaterial):
        self.materials.append(material)
		
		
13. Discuss the challenges and drawbacks of composition, such as increased complexity and potential for tight coupling between objects.
Increased Complexity: Composed objects can add complexity to the design, as you need to manage many smaller objects within larger ones.
Tight Coupling: If one object is modified, it may impact other objects that rely on it.


14. Create a Python class hierarchy for a restaurant system, using composition to represent menus, dishes, and ingredients.

class Dish:
    def __init__(self, name, price):
        self.name = name
        self.price = price

class Menu:
    def __init__(self):
        self.dishes = []

    def add_dish(self, dish: Dish):
        self.dishes.append(dish)

class Restaurant:
    def __init__(self):
        self.menu = Menu()

    def serve(self):
        for dish in self.menu.dishes:
            print(f"Serving {dish.name} for ${dish.price}")
			
			
15. Explain how composition enhances code maintainability and modularity in Python programs.
Modularity: The code is divided into smaller components, making it easier to maintain and update.
Reusability: Components can be reused across different classes, leading to less duplication.


16. Create a Python class for a computer game character, using composition to represent attributes like weapons, armor, and inventory.

class Weapon:
    def __init__(self, name):
        self.name = name

class Armor:
    def __init__(self, name):
        self.name = name

class Inventory:
    def __init__(self):
        self.items = []

    def add_item(self, item):
        self.items.append(item)

class Character:
    def __init__(self):
        self.weapon = Weapon("Sword")
        self.armor = Armor("Shield")
        self.inventory = Inventory()

    def show_inventory(self):
        for item in self.inventory.items:
            print(f"Item: {item}")
			
			
17. Describe the concept of "aggregation" in composition and how it differs from simple composition.

Composition: Objects are tightly bound and dependent on the parent class, often created and destroyed along with the parent.
Aggregation: Objects exist independently and can be shared across multiple classes.
18. Create a Python class for a house, using composition to represent rooms, furniture, and appliances.

class Room:
    def __init__(self, name):
        self.name = name

class Furniture:
    def __init__(self, type):
        self.type = type

class House:
    def __init__(self):
        self.rooms = [Room("Living Room"), Room("Bedroom")]
        self.furniture = [Furniture("Sofa"), Furniture("Bed")]
		
		
19. How can you achieve flexibility in composed objects by allowing them to be replaced or modified dynamically at runtime?
You can dynamically replace or modify components during runtime by reassigning the composed objects.


class Computer:
    def __init__(self):
        self.cpu = CPU()

    def upgrade(self, new_cpu):
        self.cpu = new_cpu
		
		
20. Create a Python class for a social media application, using composition to represent users, posts, and comments.

class Post:
    def __init__(self, content):
        self.content = content

class User:
    def __init__(self, username):
        self.username = username
        self.posts = []

    def create_post(self, content):
        post = Post(content)
        self.posts.append(post)

class SocialMedia:
    def __init__(self):
        self.users = []

    def add_user(self, user: User):
        self.users.append(user)




